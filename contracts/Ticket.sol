// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "@openzeppelin/contracts@4.6.0/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts@4.6.0/utils/Counters.sol";

import {IVRFCoordinatorV2Plus} from "@chainlink/contracts@1.1.0/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol";
import {VRFConsumerBaseV2Plus} from "@chainlink/contracts@1.1.0/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "@chainlink/contracts@1.1.0/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";
import {PriceConverter} from "./PriceConverter.sol"; 
import {MetaDataGenerator} from "./MetaDataGenerator.sol";

/// @notice Interface to interact with PriceConverter.sol
interface PriceConverterInterface {
    function convertUsdToMatic(uint256 ticketPrice) external view returns (uint256);
}

/// @notice Interface to interact with MetaDataGenerator.sol
interface NFTMetaDataGeneratorInterface {
    function generateMetaData(uint256 _randomNumber,  uint256 tokenId, string memory _score) external pure returns (string memory);
}

/**
    @title This contract implements a ticketing system that uses Chainlink Price Feed and VRF. 
    @author Minal Abayasekara
*/
contract Ticket is ERC721, ERC721URIStorage, VRFConsumerBaseV2Plus {

    /// @notice This allows the contract to use the Counters library's Counter type, which is a simple way to keep track of a number by incrementing and decrementing it by a given amount.
    using Counters for Counters.Counter;
    Counters.Counter internal tokenIdCounter;

    /**
       @notice Event to trigger the request to Chainlink VRF
       @param requestId The requestId, to keep a track of the request 
       @param numWords Number of words to be generated by the Chainlink VRF
    */
    event RequestSent(uint256 requestId, uint32 numWords);
    /**
       @notice Event to trigger the fulfilment of the job
       @param requestId The requestId, to keep a track of the request 
       @param randomWords The random words generated by the VRF
     */
    event RequestFulfilled(uint256 requestId, uint256[] randomWords);
    /**
        @notice Event to trigger once the entire transaction (Pricing + nft generation) is complete
        @param tokenId The tokenId of the NFT generated
        @param nftAddress The address the NFT is generated to
        @param uniqueNumber The Random Number generated from the VRF
     */
    event TransactionComplete(uint256 tokenId, address nftAddress, uint256 uniqueNumber);

    /// @notice This struct is used by the VRFConsumerBaseV2Plus contract to manage the requests to the Chainlink VRF contract.
    struct RequestStatus {
        bool fulfilled; // whether the request has been successfully fulfilled
        bool exists; // whether a requestId exists
        uint256[] randomWords;
    }

    /// @notice mapping to keep a record of requestStatus of each requestId
    mapping(uint256 => RequestStatus)
        internal s_requests; /* requestId --> requestStatus */

    /// @notice Stores the IVRFCoordinatorV2Plus instance. 
    IVRFCoordinatorV2Plus internal COORDINATOR;

   /// @notice Stores the VRF subscription Id
    uint256 internal s_subscriptionId;

    /// @notice Stores the VRF request Ids
    uint256[] internal  requestIds;
    /// @notice Stores the last requested Id
    uint256 internal lastRequestId;

    /// @notice Polygon Amoy coordinator parameters
    bytes32 immutable private keyHash = 0x816bedba8a50b294e5cbd47842baf240c2385f2eaf719edbd4f250a137a8c899;
    uint32 immutable private callbackGasLimit = 2500000;
    uint16 immutable private requestConfirmations = 3;
    uint32 immutable private numWords = 2;
    address immutable private vr_coordinator = 0x343300b5d84D444B2ADc9116FEF1bED02BE49Cf2;

    /// @notice Stores the ticket owner addresses
    mapping(uint256 => address) private ticketOwnerAddressMapping;

     /// @notice Stores the PriceConverterInterface
    PriceConverterInterface internal convertPrice;
     /// @notice Stores the NFTMetaDataGeneratorInterface
    NFTMetaDataGeneratorInterface internal nftMetaData;
     /// @notice Stores the address of the contract owner
    address private eventOwner;

    /// @notice This modifier restricts the `withdraw()` function to only be called by the event owner.
    modifier onlyEventOwner {
       require(msg.sender == eventOwner, "Cannot withdraw. You are not the event owner");
      _;
    }
   
    /// @notice Stores the contract balance
    mapping (address => uint) private _balance;

    /// @notice This struct is used to store generated Nft details
    struct nftDetails {
        uint256 tokenId;
        address ownerAdd;
        uint256 randomNum;
        uint256 randomNum2;
        uint256 finalRandomNum;
        address nftAddress;
        bool isMinted;
        bool paid;
    }

    /// @notice Stores the list of Nft details
    mapping (uint256 => nftDetails) public  listOfNftDetails;

   /**
        @notice This constructor sets up the contract by initializing. 
                Initializes the `ERC721` contract, which is responsible for implementing the ERC-721 non-fungible token (NFT) standard.
        @param _subscriptionId VRF subscription Id
        @param _nftMetaDataAddress NFT Meta Data Generator contract address
        @param _priceConverterAddress Price Converter contract address
     */
    constructor(uint256 _subscriptionId, address _nftMetaDataAddress, address _priceConverterAddress) ERC721("Chainlink Superliga FootBall 2024", "CSF")
    VRFConsumerBaseV2Plus(vr_coordinator) {
         COORDINATOR = IVRFCoordinatorV2Plus(
            vr_coordinator
        );
        s_subscriptionId = _subscriptionId;
        convertPrice = PriceConverterInterface(_priceConverterAddress);
        nftMetaData = NFTMetaDataGeneratorInterface(_nftMetaDataAddress);
        eventOwner = msg.sender;
    }


    /** 
      @notice Create the Request to generate random numbers from chainlink VRF
      @param _buyerAddress The wallet address of the buyer
      @return requestId
    */
    function safeMint(address _buyerAddress) external returns (uint256 requestId)
    {
        uint256 tokenId = tokenIdCounter.current();
        require(listOfNftDetails[tokenId].paid, "Unable to Mint... Please complete the payment process");
        // Will revert if subscription is not set and funded.
        requestId = COORDINATOR.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: keyHash,
                subId: s_subscriptionId,
                requestConfirmations: requestConfirmations,
                callbackGasLimit: callbackGasLimit,
                numWords: numWords,
                extraArgs: VRFV2PlusClient._argsToBytes(
                    VRFV2PlusClient.ExtraArgsV1({nativePayment: false})
                )
            })
        );
        s_requests[requestId] = RequestStatus({
            randomWords: new uint256[](0),
            exists: true,
            fulfilled: false
        });
        requestIds.push(requestId);
        lastRequestId = requestId;
        
        emit RequestSent(requestId, numWords);
        ticketOwnerAddressMapping[requestId] = _buyerAddress;
        
        return requestId;
    }

    /**
      @notice Fullfills the VRF request and generate the dynamic NFT 
      @dev Using the random words generated from the VRF, a random number is generated. This random number is used to generate the NFT.
      @param _requestId The request Id
      @param _randomWords The generated random words
      @inheritdoc VRFConsumerBaseV2Plus
    */
    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal  override {
        require(s_requests[_requestId].exists, "request not found");     
        s_requests[_requestId].fulfilled = true;
        s_requests[_requestId].randomWords = _randomWords;
        emit RequestFulfilled(_requestId, _randomWords);

         uint256 random1 = (_randomWords[0] % 9);
         uint256 random2 = (_randomWords[1] % 5);

        uint256 randomNumber = random1 ^ random2;
        uint256 tokenId = tokenIdCounter.current();
    
        string memory finalTokenURI = nftMetaData.generateMetaData(randomNumber, tokenId, "Match not started");
       
        address userAddr = ticketOwnerAddressMapping[_requestId];        
        tokenIdCounter.increment();
        _safeMint(userAddr, tokenId);
        _setTokenURI(tokenId, finalTokenURI);   
        updateInternalData(tokenId, random1, random2, randomNumber);
        emit TransactionComplete(tokenId, listOfNftDetails[tokenId]. nftAddress, randomNumber); 
    }

    /** 
      @notice Update the mapping which contains the NFT details
      @param _tokenId Token ID of the NFT
      @param _random1 Random Number 1 generated using the first random word
      @param _random2  Random Number 2 generated using the second random word
      @param _randomNumber The final random number generated using the XOR of random1 and random2
    */
    function updateInternalData(uint _tokenId, uint256 _random1, uint256 _random2, uint256 _randomNumber) private {
        listOfNftDetails[_tokenId].randomNum = _random1;
        listOfNftDetails[_tokenId].randomNum = _random2;
        listOfNftDetails[_tokenId].finalRandomNum = _randomNumber;
        listOfNftDetails[_tokenId].isMinted = true; 
    }

    /** 
      @notice Convert the USD price to Matic
      @param _ticketPrice Ticket price in USD
     */
    function convertUSDToMatic(uint _ticketPrice) view external returns (uint256) {
        require(_ticketPrice > 0, "Please ensure that the ticket price you entered is greater than zero.");
        return convertPrice.convertUsdToMatic(_ticketPrice);
    }

    /** 
      @notice Handles the transactions
      @param _buyerAddress The buyer's wallet address
    */
    function confirmTransaction(address _buyerAddress) external payable {
         require(msg.value > 0, "There was a problem fetching the price. Please try again");
         uint256 tokenId = tokenIdCounter.current();
         _balance[address(this)] += msg.value;
         listOfNftDetails[tokenId]  = nftDetails(tokenId,_buyerAddress, 0, 0, 0, address(this), false, true);
    }
   
   /// @notice Transfer the contract balance to the event owner's wallet
   function withdraw() public payable onlyEventOwner{
       require(address(this).balance > 0, "Your account balance is currently zero. Please make sure you have enough funds in your account before attempting to withdraw.");
       payable(eventOwner).transfer(address(this).balance);
   }

    /** 
      @notice Update the NFT meta data
      @param _score Score of the football event
    */
    function updateMetaData(string memory _score) external {
        uint256 tokenId = tokenIdCounter.current()-1;
        for (uint i = 0 ; i <= tokenId ; i++){
            string memory updatedTokenURI = nftMetaData.generateMetaData(listOfNftDetails[i].finalRandomNum, i, _score);
             _setTokenURI(i, updatedTokenURI);  
        }    
    }

    /// @notice Retrieve the status of the chainlink VRF
    function getRequestStatus(
        uint256 _requestId
    ) external view returns (bool fulfilled, uint256[] memory randomWords) {
        require(s_requests[_requestId].exists, "request not found");
        RequestStatus memory request = s_requests[_requestId];
        return (request.fulfilled, request.randomWords);
    }

    /** 
      @notice Returns the Uniform Resource Identifier (URI) for `tokenId` token.
      @inheritdoc ERC721URIStorage
    */
    function tokenURI(uint256 tokenId)
        public view override(ERC721, ERC721URIStorage) returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    /** 
      @notice destroy tokenId
      @inheritdoc ERC721URIStorage
    */
    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage)
    {
        super._burn(tokenId);
    }
}